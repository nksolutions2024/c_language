Below is a clean, correct split of your original mod35.c into three compilation units, plus the updated Makefile, while keeping behavior identical to before.
Key idea:
* Shared objects and symbols must be declared extern in other files
* file_operations must be visible to mod351.c
* One common header avoids duplication and keeps things maintainable
________________


1️⃣ Common Header (NEW) – mod35.h
This header is included by all three .c files.
#ifndef _MOD35_H_
#define _MOD35_H_


#include <linux/module.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/err.h>
#include <linux/device.h>
#include <linux/kdev_t.h>
#include <linux/cdev.h>
#include <linux/slab.h>
#include <linux/uaccess.h>


#define MY_CLASS_NAME  "cdac_cls"
#define MY_DEV_NAME    "cdac_dev"
#define MY_KBUF_SZ     (8)


/* shared globals */
extern dev_t dev;
extern struct class *dev_class;
extern struct device *cdevice;
extern struct cdev my_cdev;
extern char *kbuf;


/* file operations */
extern struct file_operations fops;


/* function prototypes */
int my_open(struct inode *inode, struct file *file);
int my_release(struct inode *inode, struct file *file);
ssize_t my_read(struct file *file, char __user *buf, size_t len, loff_t *off);
ssize_t my_write(struct file *file, const char __user *buf, size_t len, loff_t *off);


#endif


________________


2️⃣ Init / Exit Only – mod351.c
#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt


#include "mod35.h"


/* global objects */
dev_t dev = 0;
struct class *dev_class;
struct device *cdevice;
struct cdev my_cdev;
char *kbuf;


static int __init my_mod_init(void)
{
        int ans;


        kbuf = kmalloc(MY_KBUF_SZ, GFP_KERNEL);
        if (!kbuf)
                return -ENOMEM;


        pr_info("Hello world from mod35!\n");


        ans = alloc_chrdev_region(&dev, 0, 1, MY_DEV_NAME);
        if (ans < 0)
                goto r_kbuf;


        cdev_init(&my_cdev, &fops);


        ans = cdev_add(&my_cdev, dev, 1);
        if (ans < 0)
                goto r_cdev;


        dev_class = class_create(THIS_MODULE, MY_CLASS_NAME);
        if (IS_ERR(dev_class))
                goto r_class;


        cdevice = device_create(dev_class, NULL, dev, NULL, MY_DEV_NAME);
        if (IS_ERR(cdevice))
                goto r_device;


        pr_info("Device created successfully\n");
        return 0;


r_device:
        class_destroy(dev_class);
r_class:
        cdev_del(&my_cdev);
r_cdev:
        unregister_chrdev_region(dev, 1);
r_kbuf:
        kfree(kbuf);
        return -1;
}


static void __exit my_mod_exit(void)
{
        pr_info("Goodbye world from mod35!\n");
        device_destroy(dev_class, dev);
        class_destroy(dev_class);
        cdev_del(&my_cdev);
        unregister_chrdev_region(dev, 1);
        kfree(kbuf);
}


module_init(my_mod_init);
module_exit(my_mod_exit);


MODULE_LICENSE("GPL");
MODULE_AUTHOR("EDD <edd@cdac.gov.in>");
MODULE_DESCRIPTION("Passing data between user and kernel spaces module!");


________________


3️⃣ Open / Release Only – mod352.c
#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt


#include "mod35.h"


int my_open(struct inode *inode, struct file *file)
{
        pr_info("My open function called\n");
        return 0;
}


int my_release(struct inode *inode, struct file *file)
{
        pr_info("My release function called\n");
        return 0;
}


________________


4️⃣ Read / Write Only – mod353.c
#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt


#include "mod35.h"


ssize_t my_read(struct file *file, char __user *buf, size_t len, loff_t *off)
{
        pr_info("My read function called\n");


        if (copy_to_user(buf, kbuf + *off, len))
                return -EFAULT;


        *off += len;
        return len;
}


ssize_t my_write(struct file *file, const char __user *buf, size_t len, loff_t *off)
{
        pr_info("My write function called\n");


        if (copy_from_user(kbuf, buf, len))
                return -EFAULT;


        return len;
}


/* file operations defined here */
struct file_operations fops = {
        .owner   = THIS_MODULE,
        .open    = my_open,
        .read    = my_read,
        .write   = my_write,
        .release = my_release,
};


________________


5️⃣ Updated Makefile
obj-m += mod35.o
mod35-objs := mod351.o mod352.o mod353.o


KDIR = /lib/modules/$(shell uname -r)/build
PWD  := $(shell pwd)


all:
        make -C $(KDIR) M=$(PWD) modules


clean:
        make -C $(KDIR) M=$(PWD) clean


________________


6️⃣ Verification (Same as Before ✅)
make
sudo insmod mod35.ko
dmesg | tail
ls -l /dev/cdac_dev
echo "abcd" > /dev/cdac_dev
cat /dev/cdac_dev
sudo rmmod mod35


Expected:
* Device node created ✔
* open, read, write, release logs appear ✔
* Data transfer works exactly as before ✔
________________


✅ Result
* Proper modular separation
* No duplicated symbols
* Correct linkage
* Same runtime behavior